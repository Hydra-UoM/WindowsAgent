// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.
#include "Objects.h"
#include "Manager.h"
#include "MyLogManager.h"
#include "ProcessStats.h"
#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/server/TSimpleServer.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/transport/TBufferTransports.h>

#define DIV 1048576



using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;

using boost::shared_ptr;

class ProcessStatsHandler : virtual public ProcessStatsIf {
public:
	ProcessStatsHandler() {
		// Your initialization goes here
	}

	Manager manage;
	MyLogManager manager;
	Process p;
	vector< Process > proc;
	vector<ProcessF> procF;
	ProcessF pF;
	list<string>::iterator i;
	list<string> logsList;
	list<string> userList;

	MyLogRetriever myLogRetriever;

	double getTotalCPU() {
		// Your implementation goes here
		printf("getTotalCPU\n");
		return manage.GetTotalCPU();
	}

	double getTotalMemory() {
		// Your implementation goes here
		printf("getTotalMemory\n");
		return manage.GetTotalMemory();
	}

	int64_t getFreeMemory() {
		// Your implementation goes here
		MEMORYSTATUSEX statex;

		statex.dwLength = sizeof(statex);
		GlobalMemoryStatusEx(&statex);
		printf("getFreeMemory\n");
		return (statex.ullAvailPhys / DIV);

	}

	double getTotalNetDownload() {
		// Your implementation goes here
		printf("getTotalNetDownload\n");
		return manage.GetTotalNetDownload();
	}

	double getTotalNetUpload() {
		// Your implementation goes here
		printf("getTotalNetUpload\n");
		return manage.GetTotalNetUpload();
	}

	void getMaxCPU(std::vector<std::string> & _return) {
		// Your implementation goes here
		printf("getMaxCPU\n");
		p = manage.GetMaxCPU();
		_return.push_back(p.name);
		_return.push_back(std::to_string(p.value));
	}

	void getMinCPU(std::vector<std::string> & _return) {
		// Your implementation goes here
		printf("getMinCPU\n");
		p = manage.GetMinCPU();
		_return.push_back(p.name);
		_return.push_back(std::to_string(p.value));
	}

	void getMaxMemory(std::vector<std::string> & _return) {
		// Your implementation goes here
		printf("getMaxMemory\n");
		p = manage.GetMaxMemory();
		_return.push_back(p.name);
		_return.push_back(std::to_string(p.value));
	}

	void getMinMemory(std::vector<std::string> & _return) {
		// Your implementation goes here
		printf("getMinMemory\n");
		p = manage.GetMinMemory();
		_return.push_back(p.name);
		_return.push_back(std::to_string(p.value));
	}

	void getMaxNetDownload(std::vector<std::string> & _return) {
		// Your implementation goes here
		printf("getMaxNetDownload\n");
		p = manage.GetMaxNetDownload();
		_return.push_back(p.name);
		_return.push_back(std::to_string(p.value));
	}

	void getMinNetDownload(std::vector<std::string> & _return) {
		// Your implementation goes here
		printf("getMinNetDownload\n");
		p = manage.GetMinNetDownload();
		_return.push_back(p.name);
		_return.push_back(std::to_string(p.value));
	}

	void getMaxNetUpload(std::vector<std::string> & _return) {
		// Your implementation goes here
		printf("getMaxNetUpload\n");
		p = manage.GetMaxNetUpload();
		_return.push_back(p.name);
		_return.push_back(std::to_string(p.value));
	}

	void getMinNetUpload(std::vector<std::string> & _return) {
		// Your implementation goes here
		printf("getMinNetUpload\n");
		p = manage.GetMinNetUpload();
		_return.push_back(p.name);
		_return.push_back(std::to_string(p.value));
	}

	void getAllCpuProc(std::vector<std::string> & _return) {
		// Your implementation goes here
		printf("getAllCpuProc\n");
		proc = manage.GetAllCpuProc();
		for (auto i : proc)
		{
			_return.push_back(i.name);
			_return.push_back(std::to_string(i.value));
		}
	}

	void getAllMemProc(std::vector<std::string> & _return) {
		// Your implementation goes here
		printf("getAllMemProc\n");
		proc = manage.GetAllMemProc();
		for (auto i : proc)
		{
			_return.push_back(i.name);
			_return.push_back(std::to_string(i.value));
		}
	}

	void getAllNetDownloadProc(std::vector<std::string> & _return) {
		// Your implementation goes here
		printf("getAllNetDownloadProc\n");
		proc = manage.GetAllNetDownloadProc();
		for (auto i : proc)
		{
			_return.push_back(i.name);
			_return.push_back(std::to_string(i.value));
		}
	}

	void getAllNetUploadProc(std::vector<std::string> & _return) {
		// Your implementation goes here
		printf("getAllNetUploadProc\n");
		proc = manage.GetAllNetUploadProc();
		for (auto i : proc)
		{
			_return.push_back(i.name);
			_return.push_back(std::to_string(i.value));
		}
	}

	void filterAllProcesses(std::vector<std::string> & _return, const double cpu, const double mem, const double down, const double up) {
		// Your implementation goes here
		printf("filterAllProcesses\n");
		procF = manage.FilterAllProcesses(cpu, mem, down, up);
		for (auto i : procF)
		{
			_return.push_back(i.name);
			_return.push_back(std::to_string(i.cpu));
			_return.push_back(std::to_string(i.mem));
			_return.push_back(std::to_string(i.down));
			_return.push_back(std::to_string(i.up));
		}
	}

	void filterAllAvgProcesses(std::vector<std::string> & _return, const int64_t sample, const double cpu, const double mem, const double down, const double up) {
		// Your implementation goes here
		printf("filterAllAvgProcesses\n");
		procF = manage.FilterAllAvgProcesses(sample, cpu, mem, down, up);
		for (auto i : procF)
		{
			_return.push_back(i.name);
			_return.push_back(std::to_string(i.cpu));
			_return.push_back(std::to_string(i.mem));
			_return.push_back(std::to_string(i.down));
			_return.push_back(std::to_string(i.up));
		}

	}

	void getAvgProcess_PID(std::vector<std::string> & _return, const int64_t PID, const int64_t sample) {
		// Your implementation goes here
		printf("getAvgProcess_PID\n");
		pF = manage.GetAvgProcess_PID(PID, sample);
		_return.push_back(pF.name);
		_return.push_back(std::to_string(pF.cpu));
		_return.push_back(std::to_string(pF.mem));
		_return.push_back(std::to_string(pF.down));
		_return.push_back(std::to_string(pF.up));
		_return.push_back(std::to_string(pF.avgcpu));
		_return.push_back(std::to_string(pF.avgmem));
		_return.push_back(std::to_string(pF.avgdown));
		_return.push_back(std::to_string(pF.avgup));

	}

	void getAllProcesses(std::vector<std::string> & _return) {
		// Your implementation goes here
		printf("getAllProcesses\n");
		procF = manage.GetAllProcesses();
		for (auto i : procF)
		{
			_return.push_back(i.name);
			_return.push_back(std::to_string(i.cpu));
			_return.push_back(std::to_string(i.mem));
			_return.push_back(std::to_string(i.down));
			_return.push_back(std::to_string(i.up));
		}
	}

	void getNetwork(std::vector<std::string> & _return) {
		// Your implementation goes here
		printf("getNetwork\n");
		list<string> NetList;
		list<string>::iterator itr;
		NetwerkObject Net;

		NetList.clear();
		NetList = Net.getNetwork();
		for (itr = NetList.begin(); itr != NetList.end(); ++itr)
		{
			_return.push_back(*itr);
		}

	}

	void getTCP(std::vector<std::string> & _return) {
		// Your implementation goes here
		printf("getTCP\n");
		list<string> TCPlist;
		list<string>::iterator itr1;
		TCPObject Tcp;
		TCPlist = Tcp.getTCP();
		for (itr1 = TCPlist.begin(); itr1 != TCPlist.end(); ++itr1)
		{
			_return.push_back(*itr1);
		}
	}

	void getLogonFailures(std::vector<std::string> & _return) {
		// Your implementation goes here
		printf("getLogonFailures\n");
		logsList = manager.getLogonFailures();
		for (i = logsList.begin(); i != logsList.end(); ++i){
			_return.push_back(*i);

		}
	}

	void getLogsForAllProcesses(std::vector<std::string> & _return) {
		// Your implementation goes here
		printf("getLogsForAllProcesses\n");
		manager.getLogsForAllProcesses();
		myLogRetriever.handleLogRetrivalInfo(manager.logType, manager.strSecurityLevelConstraint, manager.process_id, manager.timePeriodInMilliSeconds);
		//myLogRetriever.getLogs();
			//hasLogsListUpdated = false;
			myLogRetriever.getEvents(myLogRetriever.lpcwstrLogType, myLogRetriever.pwsQuery, myLogRetriever.process_id);
			myLogRetriever.printResultedEvent(myLogRetriever.myLogStructures, myLogRetriever.numberOfAvailableEvents);

			logsList = myLogRetriever.returnResultedEvent(myLogRetriever.myLogStructures, myLogRetriever.numberOfAvailableEvents);

			for (i = logsList.begin(); i != logsList.end(); ++i){
				_return.push_back(*i);

				// need to send event in this point
				myLogRetriever.numberOfAvailableEvents = 0;
				//releaseMemory();
				Sleep(myLogRetriever.timePeriodInMilliSeconds);
			}
	}

	void getLogsForAProcess(std::vector<std::string> & _return) {
		// Your implementation goes here
		printf("getLogsForAProcess\n");
		manager.getLogsForAProcess();
		myLogRetriever.handleLogRetrivalInfo(manager.logType, manager.strSecurityLevelConstraint, manager.process_id, manager.timePeriodInMilliSeconds);
		
			//hasLogsListUpdated = false;
			myLogRetriever.getEvents(myLogRetriever.lpcwstrLogType, myLogRetriever.pwsQuery, myLogRetriever.process_id);
			myLogRetriever.printResultedEvent(myLogRetriever.myLogStructures, myLogRetriever.numberOfAvailableEvents);

			logsList = myLogRetriever.returnResultedEvent(myLogRetriever.myLogStructures, myLogRetriever.numberOfAvailableEvents);

			for (i = logsList.begin(); i != logsList.end(); ++i){
				_return.push_back(*i);

				// need to send event in this point
				myLogRetriever.numberOfAvailableEvents = 0;
				//releaseMemory();
				Sleep(myLogRetriever.timePeriodInMilliSeconds);
			}
		
	}

	void getLogsForAllProcessesWithSecurityConstraint(std::vector<std::string> & _return) {
		// Your implementation goes here
		printf("getLogsForAllProcessesWithSecurityConstraint\n");
		manager.getLogsForAllProcessesWithSecurityConstraint();
		myLogRetriever.handleLogRetrivalInfo(manager.logType, manager.strSecurityLevelConstraint, manager.process_id, manager.timePeriodInMilliSeconds);
		
			//hasLogsListUpdated = false;
			myLogRetriever.getEvents(myLogRetriever.lpcwstrLogType, myLogRetriever.pwsQuery, myLogRetriever.process_id);
			myLogRetriever.printResultedEvent(myLogRetriever.myLogStructures, myLogRetriever.numberOfAvailableEvents);

			logsList = myLogRetriever.returnResultedEvent(myLogRetriever.myLogStructures, myLogRetriever.numberOfAvailableEvents);
			
			//list<string>::iterator i;
			for (i = logsList.begin(); i != logsList.end(); ++i){
				_return.push_back(*i);

				// need to send event in this point
				myLogRetriever.numberOfAvailableEvents = 0;
				//releaseMemory();
				Sleep(myLogRetriever.timePeriodInMilliSeconds);
			
		}

	}

	void getCurrentLoggedInUser(std::vector<std::string> & _return) {
		// Your implementation goes here
		printf("getCurrentLoggedInUser\n");
		userList = manager.getCurrentLoggedInUser();  // return list<string>

		for (i = userList.begin(); i != userList.end(); ++i)
			_return.push_back(*i);
	}

	void getAllUserInformation(std::vector<std::string> & _return) {
		// Your implementation goes here
		printf("getAllUserInformation\n");
		userList = manager.getAllUserInformation();	// return list<string>

		for (i = userList.begin(); i != userList.end(); ++i)
			_return.push_back(*i);
	}

	void getSuccessLoginInformation(std::vector<std::string> & _return) {
		// Your implementation goes here
		printf("getSuccessLoginInformation\n");
		logsList = manager.getSuccessLoginInformation(); // return list<string>
		for (i = logsList.begin(); i != logsList.end(); ++i)
			_return.push_back(*i);
	}

};

int main(int argc, char **argv) {
	WSADATA wsaData = {};
	WORD wVersionRequested = MAKEWORD(2, 2);
	int err = WSAStartup(wVersionRequested, &wsaData);

	int port = 9090;
	using boost::shared_ptr;
	shared_ptr<ProcessStatsHandler> handler(new ProcessStatsHandler());
	shared_ptr<TProcessor> processor(new ProcessStatsProcessor(handler));
	shared_ptr<TServerTransport> serverTransport(new TServerSocket(port));
	shared_ptr<TTransportFactory> transportFactory(new TBufferedTransportFactory());
	shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());

	TSimpleServer server(processor, serverTransport, transportFactory, protocolFactory);
	server.serve();
	return 0;
}

